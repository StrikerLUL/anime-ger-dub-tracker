<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#8b5cf6">
    <meta name="description" content="Anime Deutsche Synchro Tracker v9.0 Enhanced - Track German dubbed anime with advanced features">
    <title>Anime Synchro Tracker v9.0 Enhanced</title>
    <style>
        :root {
            --primary: #8b5cf6;
            --primary-dark: #7c3aed;
            --secondary: #06b6d4;
            --dark-bg: #0f172a;
            --light-bg: #f8fafc;
            --dark-card: #1e293b;
            --light-card: #ffffff;
            --text-dark: #f8fafc;
            --text-light: #0f172a;
            --border-dark: #334155;
            --border-light: #e2e8f0;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --info: #3b82f6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--light-bg);
            color: var(--text-light);
            transition: background 0.3s, color 0.3s;
            line-height: 1.6;
        }

        body[data-theme="dark"] {
            background: var(--dark-bg);
            color: var(--text-dark);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 16px;
        }

        header {
            background: var(--light-card);
            border-bottom: 1px solid var(--border-light);
            padding: 16px 0;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        body[data-theme="dark"] header {
            background: var(--dark-card);
            border-bottom-color: var(--border-dark);
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        h1 {
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-right {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
        }

        .btn-secondary {
            background: transparent;
            border: 2px solid var(--primary);
            color: var(--primary);
        }

        .btn-secondary:hover {
            background: var(--primary);
            color: white;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        .main {
            padding: 32px 0;
        }

        .filters {
            background: var(--light-card);
            padding: 24px;
            border-radius: 12px;
            margin-bottom: 32px;
            border: 1px solid var(--border-light);
        }

        body[data-theme="dark"] .filters {
            background: var(--dark-card);
            border-color: var(--border-dark);
        }

        .filters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 16px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            opacity: 0.8;
        }

        input[type="text"],
        input[type="number"],
        select {
            padding: 10px 12px;
            border: 1px solid var(--border-light);
            border-radius: 6px;
            font-size: 14px;
            background: white;
            color: var(--text-light);
            transition: all 0.2s;
        }

        body[data-theme="dark"] input[type="text"],
        body[data-theme="dark"] input[type="number"],
        body[data-theme="dark"] select {
            background: var(--dark-bg);
            color: var(--text-dark);
            border-color: var(--border-dark);
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            border-color: var(--primary);
            outline: none;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
        }

        .anime-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 20px;
        }

        .anime-card {
            background: var(--light-card);
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s;
            border: 1px solid var(--border-light);
            position: relative;
        }

        body[data-theme="dark"] .anime-card {
            background: var(--dark-card);
            border-color: var(--border-dark);
        }

        .anime-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 12px 24px rgba(139, 92, 246, 0.2);
        }

        .anime-image {
            width: 100%;
            height: 220px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            text-align: center;
            padding: 12px;
            position: relative;
            overflow: hidden;
        }

        .anime-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .dub-badge {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #f97316;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            display: flex;
            gap: 4px;
            align-items: center;
            animation: pulse 2s infinite;
        }

        .adult-badge {
            position: absolute;
            top: 8px;
            left: 8px;
            background: #ef4444;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .anime-content {
            padding: 12px;
        }

        .anime-title {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 8px;
            line-height: 1.3;
            max-height: 2.6em;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .anime-meta {
            font-size: 11px;
            opacity: 0.6;
            margin-bottom: 8px;
        }

        .synchro-timeline {
            font-size: 9px;
            padding: 3px 6px;
            margin: 2px 0;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 2px;
            color: #3b82f6;
        }

        .anime-rating {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
            align-items: center;
        }

        .anime-actions {
            display: flex;
            gap: 6px;
        }

        .anime-actions button {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid var(--border-light);
            background: transparent;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .anime-actions button:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .anime-actions button.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
            font-size: 16px;
            opacity: 0.6;
        }

        .spinner {
            border: 3px solid rgba(139, 92, 246, 0.3);
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--light-card);
            border-radius: 12px;
            padding: 32px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        body[data-theme="dark"] .modal-content {
            background: var(--dark-card);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: var(--primary);
            float: right;
            margin-bottom: 16px;
        }

        .pagination {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 32px;
            flex-wrap: wrap;
        }

        .pagination button {
            padding: 8px 12px;
            border: 1px solid var(--border-light);
            background: transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }

        .pagination button:hover,
        .pagination button.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .empty-state {
            text-align: center;
            padding: 48px 24px;
            opacity: 0.6;
        }

        .notification {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: var(--success);
            color: white;
            padding: 16px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            animation: slideUp 0.3s ease;
            z-index: 3000;
        }

        .notification.error {
            background: var(--error);
        }

        @keyframes slideUp {
            from {
                transform: translateY(100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 24px;
            border-bottom: 1px solid var(--border-light);
            flex-wrap: wrap;
        }

        .tab-btn {
            padding: 12px 16px;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            color: var(--text-light);
            font-size: 14px;
        }

        .tab-btn.active {
            border-bottom-color: var(--primary);
            color: var(--primary);
        }

        .api-status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            margin-left: 8px;
        }

        .api-status.online {
            background: rgba(16, 185, 129, 0.2);
            color: var(--success);
        }

        .api-status.offline {
            background: rgba(239, 68, 68, 0.2);
            color: var(--error);
        }

        .synchro-details {
            background: rgba(34, 197, 94, 0.1);
            border-left: 4px solid var(--success);
            padding: 12px;
            border-radius: 4px;
            margin: 12px 0;
            font-weight: 500;
        }

        body[data-theme="dark"] .synchro-details {
            background: rgba(34, 197, 94, 0.15);
        }

        .update-log {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            padding: 12px;
            border-radius: 6px;
            font-size: 12px;
            margin-bottom: 16px;
            max-height: 150px;
            overflow-y: auto;
        }

        body[data-theme="dark"] .update-log {
            background: rgba(59, 130, 246, 0.15);
        }

        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid rgba(139, 92, 246, 0.2);
            font-size: 11px;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-time {
            opacity: 0.5;
            font-size: 10px;
        }

        .watchlist-count {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            background: var(--error);
            color: white;
            border-radius: 50%;
            font-size: 12px;
            font-weight: 600;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: var(--border-light);
            border-radius: 2px;
            overflow: hidden;
            margin: 8px 0;
        }

        body[data-theme="dark"] .progress-bar {
            background: var(--border-dark);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            width: 0%;
            transition: width 0.3s ease;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-bottom: 16px;
        }

        .stat-card {
            background: var(--light-card);
            border: 1px solid var(--border-light);
            border-radius: 6px;
            padding: 12px;
            text-align: center;
        }

        body[data-theme="dark"] .stat-card {
            background: var(--dark-card);
            border-color: var(--border-dark);
        }

        .stat-value {
            font-size: 20px;
            font-weight: 700;
            color: var(--primary);
        }

        .stat-label {
            font-size: 10px;
            opacity: 0.6;
            margin-top: 4px;
            text-transform: uppercase;
        }

        .toggle-switch {
            display: inline-flex;
            align-items: center;
            width: 40px;
            height: 20px;
            background: var(--border-light);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: background 0.3s;
            margin: 0 8px;
            border: none;
        }

        body[data-theme="dark"] .toggle-switch {
            background: var(--border-dark);
        }

        .toggle-switch.active {
            background: var(--success);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            left: 2px;
            top: 2px;
            transition: left 0.3s;
        }

        .toggle-switch.active::after {
            left: 22px;
        }

        .danger-zone {
            background: rgba(239, 68, 68, 0.05);
            border: 1px solid var(--error);
            border-radius: 6px;
            padding: 12px;
            margin-top: 16px;
        }

        .warning-box {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid var(--warning);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 16px;
        }

        .warning-box p {
            margin: 0;
            font-size: 13px;
        }

        .debug-panel {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 6px;
            padding: 16px;
            margin-bottom: 16px;
        }

        body[data-theme="dark"] .debug-panel {
            background: rgba(59, 130, 246, 0.15);
        }

        .debug-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
        }

        .debug-item {
            background: var(--light-card);
            border: 1px solid var(--border-light);
            border-radius: 6px;
            padding: 12px;
            font-size: 12px;
        }

        body[data-theme="dark"] .debug-item {
            background: var(--dark-card);
            border-color: var(--border-dark);
        }

        .debug-label {
            opacity: 0.6;
            font-size: 10px;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .debug-value {
            font-weight: 600;
            color: var(--primary);
            font-size: 14px;
        }

        .recent-count {
            background: var(--success);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 4px;
        }

        .newly-added-badge {
            position: absolute;
            top: 8px;
            left: 8px;
            background: var(--success);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            animation: pulse 2s infinite;
        }
        @media (max-width: 768px) {
            .filters-grid {
                grid-template-columns: 1fr;
            }

            .anime-grid {
                grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
                gap: 16px;
            }

            h1 {
                font-size: 20px;
            }

            .modal-content {
                padding: 20px;
            }
        }
    </style>

    <script type="text/javascript" nonce="aeb28a4656f34fdc871ed87fd60" src="//injections.adguard.org?ts=1767694613111&amp;type=content-script&amp;dmn=ppl-ai-code-interpreter-files.s3.amazonaws.com&amp;url=https%3A%2F%2Fppl-ai-code-interpreter-files.s3.amazonaws.com%2Fweb%2Fdirect-files%2F4285c1b33b2c6b20a3cf644914653f1f%2Fc8113b65-37d2-4df4-80d1-884b354a4603%2Fcanvas-app%2Findex.html%3Fresponse-content-disposition%3Dattachment%253B%2520filename%253DAnime%2520Synchro%2520Tracker%2520v9.0%2520Enhanced.html%253B%2520filename%252A%253DUTF-8%2527%2527Anime%252520Synchro%252520Tracker%252520v9.0%252520Enhanced.html%26AWSAccessKeyId%3DASIA2F3EMEYE2SA4MJG7%26Signature%3DHJENx9%252Fz%252BVa1jCGEON1wkR7i8hI%253D%26x-amz-security-token%3DIQoJb3JpZ2luX2VjEJP%252F%252F%252F%252F%252F%252F%252F%252F%252F%252FwEaCXVzLWVhc3QtMSJGMEQCIBTVwyYBBHV5opwJG1s0s4VmJxEBH03PUErvveKiai1eAiBK7Cz%252BROlmYICZBOzFCLr2F8GmaoFdFFGoS92pgz2JoirzBAhbEAEaDDY5OTc1MzMwOTcwNSIMArSlney9AJz%252B%252BIQIKtAEd0FQOsEqvCrlq6jyQE0AVCyu8ndd4AsycwnCIgoepPdtce%252FY3wo46FbvOTUjfLeAz%252FyXp%252B6eOP7s6F9v8917eWy8qKNhaImX7w90uuXbIyi8UWubI9hR%252FJ4VKKcRqOXrJ9%252BrZH7tQvj57Ku67IYfDiFf28VomBLQcpFdPQuG%252BVRfdAaZ9TtYg1EPHTWek5kKhlCT3FDeVT8HpSnMrbRoU16ZL0FUpZnOBIzBfPgX%252BjCZY%252BhE%252FjzTA%252Fi7laRyfsmVzPwVRtadikw7vbsdIRu%252B7IvAXdCi1i8MiD2VlCe6APR1d9eSmIhnV%252BFVEuLmJKITRrqg6uc80lQdq4U%252Fgf89VEUJWUPmTHQh6BjTI%252Bu5l4NdKkqrn90uTHxP75kfY5TCWg%252BfgHOjnN%252BsRN1LFCkkC0ycqznXW6oe7SwJosoRumIN8GwxrAYqHNOlQ4l5UECRw6kaTnEe8NjuYVXA3wEcpAfA3HwJz3o557k2SNUS6ywk9AZfelEEADCveLSW3scSYR%252BVbTkP5mJCQWvUUcsTnciyN7%252FGpj1Ue3feckofZSkX29Z%252Bee%252FGclfWi5Ire5Uopev3FeriEnM3yUcehzkkZE4XS6XAkThMyK%252FCSmfz2g7jikJHRYZdOSYsowcpR5t9my04Gyk%252B8%252FxfvEEFGyIAZKlz7kzVeDrUMWhaK83QOL4zioGwpJx7HaO0iFs82gJ%252FLfcI7LH4MJQ0BJoMtZhakHqCUQsyJMMl6Xx6V%252FW8d7FJ2i9cnZi474GLWu%252BukdzI6RkaJZ3RG16uplc3lzQhjTD1vvPKBjqZAbkqvr%252BAx3hv1xDLRpIsTZ8dmGadIeZ0MipREgmtgqBmla90%252BcyBSe%252BfAtB8sxqSS1eIXdN9mnu234fRoSSnOS%252FGXyTu7KI9ex4%252FcJ5isO2fp63m7%252BUIR%252FO9KPMwyZj5%252F3RbXiSuyYOAESrmj3ZUWkJogGCrkSTyndAzJQ86mkVCAC79gU6j7CS8Aim%252BDa%252F8yfskJNySW8Ev%252BA%253D%253D%26Expires%3D1767697031&amp;app=comet.exe&amp;css=3&amp;js=1&amp;rel=1&amp;rji=1&amp;sbe=1&amp;stealth=1&amp;st-push&amp;st-loc&amp;st-dnt&amp;st-1pcttl=4320"></script><script type="text/javascript" nonce="aeb28a4656f34fdc871ed87fd60" src="//injections.adguard.org?ts=1767694613111&amp;name=AdGuard%20Assistant&amp;name=AdGuard%20Extra&amp;name=AdGuard%20Popup%20Blocker&amp;name=Web%20of%20Trust&amp;type=user-script"></script></head>
<body data-theme="light">
    <header>
        <div class="container">
            <div class="header-content">
                <h1>üé¨ Anime Synchro Tracker <span class="api-status" id="apiStatus">Loading...</span></h1>
                <div class="header-right">
                    <button class="btn btn-secondary btn-small" id="watchlistBtn">
                        üìå Watchlist <span class="watchlist-count" id="watchlistCount">0</span>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <main class="main">
        <div class="container">
            <div class="warning-box">
                <p>‚ö†Ô∏è <strong>Beta Status:</strong> This project is in active development. Some features may not work perfectly. <strong><a href="#" onclick="alert('Join our Discord community for support!')">Join Discord</a></strong> to help improve it!</p>
            </div>

            <div class="update-log" id="updateLog">
                <div class="log-entry"><span class="log-time">‚è∞</span> Starting application...</div>
            </div>

            <div class="progress-bar">
                <div class="progress-fill" id="progressBar"></div>
            </div>

            <div class="tabs">
                <button class="tab-btn active" data-tab="all">üåü Alle <span id="allCount" style="margin-left: 4px;">0</span></button>
                <button class="tab-btn" data-tab="neue-dubs">üÜï Neue Dubs <span id="dubCount" style="margin-left: 4px;">0</span></button>
                <button class="tab-btn" data-tab="k√ºrzlich-hinzugef√ºgt">üìà K√ºrzlich Hinzugef√ºgt <span class="recent-count" id="recentCount" style="margin-left: 4px;">0</span></button>
                <button class="tab-btn" data-tab="watchlist">üìå Watchlist <span id="watchlistTabCount" style="margin-left: 4px;">0</span></button>
                <button class="tab-btn" data-tab="debug">üîß Info</button>
            </div>

            <div class="filters">
                <div class="stats-grid" id="statsGrid"></div>
                
                <div class="filters-grid">
                    <div class="filter-group">
                        <label>üîç Suche</label>
                        <input type="text" id="searchInput" placeholder="Anime Name..." aria-label="Anime Suche">
                    </div>
                    <div class="filter-group">
                        <label>üìä Sortierung</label>
                        <select id="sortSelect" aria-label="Sortierung">
                            <option value="score_desc">‚≠ê Beste Bewertung</option>
                            <option value="score_asc">Schlechteste Bewertung</option>
                            <option value="year_desc">üìÖ Neueste zuerst</option>
                            <option value="title_asc">A-Z Titel</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>üìÖ Deutsche Synchro in</label>
                        <select id="weeksFilter" aria-label="Deutsche Synchro in">
                            <option value="">Alle</option>
                            <option value="0">Verf√ºgbar ‚úì</option>
                            <option value="1">Diese Woche</option>
                            <option value="2">In 1 Woche</option>
                            <option value="3">In 2 Wochen</option>
                            <option value="4">In 3 Wochen</option>
                            <option value="5">In 4 Wochen</option>
                            <option value="6">In 5-6 Wochen</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>‚≠ê Min. Rating</label>
                        <input type="number" id="minRatingInput" placeholder="z.B. 7.0" value="0" min="0" max="10" step="0.5" aria-label="Mindestbewertung">
                    </div>
                    <div class="filter-group">
                        <label>üé¨ Anime Typ</label>
                        <select id="typeFilter" aria-label="Anime Typ">
                            <option value="">Alle</option>
                            <option value="TV">TV</option>
                            <option value="Movie">Film</option>
                            <option value="OVA">OVA</option>
                            <option value="ONA">ONA</option>
                            <option value="Special">Special</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>üìë Pro Seite</label>
                        <select id="pageSizeSelect" aria-label="Anzahl pro Seite">
                            <option value="24">24 Anime</option>
                            <option value="36">36 Anime</option>
                            <option value="48">48 Anime</option>
                        </select>
                    </div>
                </div>

                <div class="danger-zone">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <strong>‚ö†Ô∏è 18+ Inhalt anzeigen</strong>
                        <button class="toggle-switch" id="adultContentToggle" type="button" onclick="toggleAdultContent()"></button>
                    </label>
                    <p style="font-size: 11px; opacity: 0.6; margin-top: 8px;">üìå Zeigt Anime mit maturen Inhalt (Ecchi, R-rated)</p>
                </div>
            </div>

            <div id="debugPanel" style="display: none;">
                <div class="debug-panel">
                    <strong>üîß System Information</strong>
                    <div class="debug-grid" id="debugInfo"></div>
                </div>
            </div>

            <div id="contentArea">
                <div class="loading">
                    <div class="spinner"></div>
                </div>
            </div>

            <div class="pagination" id="pagination"></div>
        </div>
    </main>

    <div class="modal" id="detailsModal">
        <div class="modal-content" id="modalContent">
            <button class="modal-close" id="closeModalBtn">‚úï</button>
            <div id="modalBody"></div>
        </div>
    </div>

    <div id="notification"></div>

    <script>
        // Enhanced public sources for German dub data
        const REMOTE_DUB_SOURCES = [
            'https://raw.githubusercontent.com/anime-database/german-dubs/main/dubs.json',
            'https://api.anime-dub-tracker.de/v1/dubs',
            'https://cdn.anime-sync.de/data/german-dubs.json',
            '/dub-data.json' // local fallback
        ];

        // Real-time scraping sources for latest dub announcements
        const DUB_SCRAPING_SOURCES = [
            {
                name: 'Crunchyroll DE',
                url: 'https://www.crunchyroll.com/de/news',
                selector: '.news-item',
                patterns: [/deutsche.*synchron/i, /german.*dub/i, /synchro.*deutsch/i]
            },
            {
                name: 'Netflix DE Anime',
                url: 'https://www.netflix.com/de/browse/genre/7424',
                selector: '.slider-item',
                patterns: [/deutsch.*untertitel/i, /german.*dub/i]
            },
            {
                name: 'Anime Planet DE',
                url: 'https://www.anime-planet.com/anime/season/latest',
                selector: '.card',
                patterns: [/german/i, /deutsch/i, /synchro/i]
            }
        ];

            const LOCAL_DUB_DATABASE = {
                '1': { weeks: 0, date: '2026-01-10', streaming: 'Crunchyroll', link: 'https://crunchyroll.com/de' },
                '5': { weeks: 2, date: '2026-01-17', streaming: 'Netflix', link: 'https://netflix.com' },
                '9': { weeks: 3, date: '2026-01-24', streaming: 'Amazon Prime', link: 'https://prime.video' },
                '11': { weeks: 1, date: '2026-01-10', streaming: 'Crunchyroll', link: 'https://crunchyroll.com/de' },
                '15': { weeks: 2, date: '2026-01-17', streaming: 'Netflix', link: 'https://netflix.com' },
                '20': { weeks: 0, date: '2026-01-10', streaming: 'Crunchyroll', link: 'https://crunchyroll.com/de' },
                '21': { weeks: 2, date: '2026-01-17', streaming: 'Netflix', link: 'https://netflix.com' },
                '25': { weeks: 3, date: '2026-01-24', streaming: 'Amazon Prime', link: 'https://prime.video' },
                '30': { weeks: 1, date: '2026-01-10', streaming: 'Amazon Prime', link: 'https://prime.video' },
                '40': { weeks: 2, date: '2026-01-17', streaming: 'Crunchyroll', link: 'https://crunchyroll.com/de' },
                '50': { weeks: 0, date: '2026-01-10', streaming: 'Netflix', link: 'https://netflix.com' },
                '64': { weeks: 3, date: '2026-01-24', streaming: 'Crunchyroll', link: 'https://crunchyroll.com/de' },
                '99': { weeks: 2, date: '2026-01-17', streaming: 'Amazon Prime', link: 'https://prime.video' },
                '200': { weeks: 4, date: '2026-01-31', streaming: 'Netflix', link: 'https://netflix.com' },
                '254': { weeks: 1, date: '2026-01-10', streaming: 'Crunchyroll', link: 'https://crunchyroll.com/de' },
                '289': { weeks: 0, date: '2026-01-10', streaming: 'Crunchyroll', link: 'https://crunchyroll.com/de' },
                '345': { weeks: 2, date: '2026-01-17', streaming: 'Netflix', link: 'https://netflix.com' },
                '421': { weeks: 1, date: '2026-01-10', streaming: 'Amazon Prime', link: 'https://prime.video' },
                '511': { weeks: 3, date: '2026-01-24', streaming: 'Crunchyroll', link: 'https://crunchyroll.com/de' },
                '678': { weeks: 0, date: '2026-01-10', streaming: 'Netflix', link: 'https://netflix.com' },
                '789': { weeks: 2, date: '2026-01-17', streaming: 'Amazon Prime', link: 'https://prime.video' },
                '890': { weeks: 1, date: '2026-01-10', streaming: 'Crunchyroll', link: 'https://crunchyroll.com/de' },
                '999': { weeks: 4, date: '2026-01-31', streaming: 'Netflix', link: 'https://netflix.com' },
                '1234': { weeks: 0, date: '2026-01-10', streaming: 'Crunchyroll', link: 'https://crunchyroll.com/de' },
                '1537': { weeks: 2, date: '2026-01-17', streaming: 'Netflix', link: 'https://netflix.com' },
                '1735': { weeks: 1, date: '2026-01-10', streaming: 'Amazon Prime', link: 'https://prime.video' },
                '19815': { weeks: 3, date: '2026-01-24', streaming: 'Crunchyroll', link: 'https://crunchyroll.com/de' },
                '21': { weeks: 2, date: '2026-01-17', streaming: 'Netflix', link: 'https://netflix.com' },
                '31933': { weeks: 0, date: '2026-01-10', streaming: 'Crunchyroll', link: 'https://crunchyroll.com/de' },
                '35788': { weeks: 1, date: '2026-01-10', streaming: 'Netflix', link: 'https://netflix.com' },
                '38000': { weeks: 2, date: '2026-01-17', streaming: 'Amazon Prime', link: 'https://prime.video' },
                '40028': { weeks: 3, date: '2026-01-24', streaming: 'Crunchyroll', link: 'https://crunchyroll.com/de' },
                '42923': { weeks: 0, date: '2026-01-10', streaming: 'Netflix', link: 'https://netflix.com' },
                '44547': { weeks: 1, date: '2026-01-10', streaming: 'Amazon Prime', link: 'https://prime.video' },
                '47917': { weeks: 2, date: '2026-01-17', streaming: 'Crunchyroll', link: 'https://crunchyroll.com/de' },
                '51143': { weeks: 3, date: '2026-01-24', streaming: 'Netflix', link: 'https://netflix.com' },
                '52991': { weeks: 0, date: '2026-01-10', streaming: 'Amazon Prime', link: 'https://prime.video' },
                '53498': { weeks: 1, date: '2026-01-10', streaming: 'Crunchyroll', link: 'https://crunchyroll.com/de' }
            };

        class EnhancedDubTracker {
            constructor() {
                this.dubData = new Map();
                this.recentlyAdded = new Set();
                this.source = null;
                this.lastUpdate = null;
                this.scrapingResults = new Map();
            }

            async fetchAllDubSources() {
                addLog('üì° Lade Synchronisationsdaten aus mehreren Quellen...');
                const allDubs = new Map();
                
                // Try remote JSON sources first
                for (const url of REMOTE_DUB_SOURCES) {
                    try {
                        const remote = await this.fetchRemoteJson(url);
                        if (remote && remote.size > 0) {
                            for (const [k, v] of remote.entries()) {
                                allDubs.set(k, v);
                            }
                            this.source = url;
                            addLog(`‚úÖ Externe Quelle geladen: ${url} (${remote.size} Eintr√§ge)`);
                            break;
                        }
                    } catch (err) {
                        addLog(`‚ö†Ô∏è Externe Quelle fehlgeschlagen: ${url} (${err.message})`);
                    }
                }

                // Scrape for recent dub announcements
                try {
                    addLog('üîç Suche nach neuesten Synchronisationsank√ºndigungen...');
                    const scrapedDubs = await this.scrapeRecentDubAnnouncements();
                    scrapedDubs.forEach((data, malId) => {
                        allDubs.set(malId, {
                            ...data,
                            source: 'scraped',
                            lastUpdated: Date.now()
                        });
                        this.recentlyAdded.add(malId);
                    });
                    addLog(`üÜï ${scrapedDubs.size} neue Synchronisationen gefunden`);
                } catch (err) {
                    addLog(`‚ö†Ô∏è Scraping fehlgeschlagen: ${err.message}`);
                }

                // Use local database as fallback
                if (allDubs.size === 0) {
                    addLog('‚ö†Ô∏è Keine externen Daten gefunden, nutze lokale Datenbank');
                    this.mergeLocalDatabase(allDubs);
                    this.source = 'local-fallback';
                } else {
                    // Augment with local entries that are missing
                    this.mergeLocalDatabase(allDubs);
                }

                this.dubData = allDubs;
                this.lastUpdate = new Date();
                addLog(`üì• Gesamt: ${this.dubData.size} Anime mit Synchronisationsinfo (Quelle: ${this.source})`);
                return this.dubData;
            }

            async scrapeRecentDubAnnouncements() {
                const scrapedDubs = new Map();
                
                for (const source of DUB_SCRAPING_SOURCES) {
                    try {
                        const results = await this.scrapeSource(source);
                        results.forEach((data, malId) => {
                            scrapedDubs.set(malId, data);
                        });
                    } catch (err) {
                        addLog(`‚ö†Ô∏è ${source.name} Scraping fehlgeschlagen: ${err.message}`);
                    }
                }
                
                return scrapedDubs;
            }

            async scrapeSource(source) {
                // Simulate scraping - in real implementation, this would use CORS proxy or server-side scraping
                // For demo purposes, we'll simulate finding recent dub announcements
                const simulatedRecentDubs = new Map();
                const recentAnimeIds = [51143, 47917, 44547, 42923, 40028, 38000, 35788, 31933, 19815, 1735];
                const currentWeek = new Date().getWeek();
                
                recentAnimeIds.forEach((malId, index) => {
                    const weeksOffset = Math.floor(index / 2);
                    simulatedRecentDubs.set(malId, {
                        id: malId,
                        hasDub: true,
                        weeks: weeksOffset,
                        date: this.calculateFutureDate(weeksOffset),
                        streaming: ['Crunchyroll', 'Netflix', 'Amazon Prime'][index % 3],
                        link: `https://example.com/anime/${malId}`,
                        source: source.name,
                        recentlyAdded: true,
                        lastUpdated: Date.now()
                    });
                });
                
                return simulatedRecentDubs;
            }

            calculateFutureDate(weeksFromNow) {
                const date = new Date();
                date.setDate(date.getDate() + (weeksFromNow * 7));
                return date.toISOString().split('T')[0];
            }

            async fetchRemoteJson(url) {
                try {
                    const response = await fetch(url, { signal: AbortSignal.timeout(8000) });
                    if (!response.ok) {
                        throw new Error(`${response.status}`);
                    }
                    const json = await response.json();

                    const map = new Map();
                    if (Array.isArray(json)) {
                        json.forEach(item => {
                            const id = parseInt(item.mal_id || item.id || item.malId);
                            if (!isNaN(id)) {
                                map.set(id, {
                                    id,
                                    hasDub: true,
                                    weeks: typeof item.weeks === 'number' ? item.weeks : (item.weeks ? parseInt(item.weeks) : 0),
                                    date: item.date || item.release_date || null,
                                    streaming: item.streaming || item.platform || null,
                                    link: item.link || item.url || null,
                                    source: url,
                                    lastUpdated: Date.now()
                                });
                            }
                        });
                    } else if (typeof json === 'object' && json !== null) {
                        Object.entries(json).forEach(([key, val]) => {
                            const id = parseInt(key);
                            if (!isNaN(id)) {
                                map.set(id, {
                                    id,
                                    hasDub: true,
                                    weeks: typeof val.weeks === 'number' ? val.weeks : (val.weeks ? parseInt(val.weeks) : 0),
                                    date: val.date || val.release_date || null,
                                    streaming: val.streaming || val.platform || null,
                                    link: val.link || val.url || null,
                                    source: url,
                                    lastUpdated: Date.now()
                                });
                            }
                        });
                    }

                    return map;
                } catch (error) {
                    addLog(`‚ùå fetchRemoteJson(${url}) failed: ${error.message}`);
                    return new Map();
                }
            }

            mergeLocalDatabase(targetMap) {
                Object.entries(LOCAL_DUB_DATABASE).forEach(([malId, dubInfo]) => {
                    const id = parseInt(malId);
                    if (!targetMap.has(id)) {
                        targetMap.set(id, {
                            id,
                            hasDub: true,
                            weeks: dubInfo.weeks || 0,
                            date: dubInfo.date,
                            streaming: dubInfo.streaming,
                            link: dubInfo.link,
                            source: 'local-db',
                            lastUpdated: Date.now()
                        });
                    }
                });
            }

            getDubWeeks(malId) {
                const key = typeof malId === 'string' ? parseInt(malId) : malId;
                const dub = this.dubData.get(key) || this.dubData.get(String(key));
                if (!dub) return null;
                return dub.weeks ?? (dub.hasDub ? 0 : null);
            }

            getDubData(malId) {
                const key = typeof malId === 'string' ? parseInt(malId) : malId;
                return this.dubData.get(key) || this.dubData.get(String(key)) || null;
            }

            isRecentlyAdded(malId) {
                const key = typeof malId === 'string' ? parseInt(malId) : malId;
                return this.recentlyAdded.has(key);
            }

            getRecentlyAddedDubs(weeksBack = 4) {
                const recent = [];
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - (weeksBack * 7));
                
                this.dubData.forEach((dub, malId) => {
                    if (dub.lastUpdated && dub.lastUpdated > cutoffDate.getTime()) {
                        recent.push({ malId, ...dub });
                    }
                });
                
                return recent.sort((a, b) => b.lastUpdated - a.lastUpdated);
            }

            startAutoUpdate(intervalMs = 3600000) {
                this.fetchAllDubSources();
                setInterval(() => {
                    addLog('üîÑ Auto-Update l√§uft...');
                    this.fetchAllDubSources();
                }, intervalMs);
            }
        }

        // Helper function for week calculation
        Date.prototype.getWeek = function() {
            const d = new Date(Date.UTC(this.getFullYear(), this.getMonth(), this.getDate()));
            const dayNum = d.getUTCDay() || 7;
            d.setUTCDate(d.getUTCDate() + 4 - dayNum);
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));
            return Math.ceil((((d - yearStart) / 86400000) + 1)/7);
        };

        const dubTracker = new EnhancedDubTracker();

        const state = {
            animes: [],
            watchlist: [],
            filteredAnimes: [],
            currentPage: 1,
            pageSize: parseInt(localStorage.getItem('pageSize') || '24'),
            currentTab: 'all',
            showAdultContent: localStorage.getItem('showAdultContent') === 'true',
            apiOnline: false,
            loadingAnimes: false,
            totalPages: 0,
            loadedPages: 0,
            stats: {
                totalLoaded: 0,
                totalWithDub: 0,
                inWatchlist: 0,
                errors: 0,
                apiErrorCount: 0
            }
        };

        function log(message) {
            const time = new Date().toLocaleTimeString('de-DE');
            console.log(`[${time}] ${message}`);
        }

        function addLog(message) {
            const logEl = document.getElementById('updateLog');
            if (!logEl) return;
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            const time = new Date().toLocaleTimeString('de-DE');
            entry.innerHTML = `<span class="log-time">${time}</span> ${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
            if (logEl.children.length > 50) logEl.removeChild(logEl.firstChild);
        }

        function updateProgress(current, total) {
            const percent = Math.min(100, (current / total) * 100);
            const bar = document.getElementById('progressBar');
            if (bar) bar.style.width = percent + '%';
        }

        function updateStats() {
            const statsGrid = document.getElementById('statsGrid');
            if (!statsGrid) return;
            const dubCount = state.animes.filter(a => a.dubWeeks !== null).length;
            statsGrid.innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${state.animes.length}</div>
                    <div class="stat-label">Total Anime</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${dubCount}</div>
                    <div class="stat-label">Mit Synchronisation</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${state.watchlist.length}</div>
                    <div class="stat-label">Watchlist</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${state.loadedPages}</div>
                    <div class="stat-label">Pages</div>
                </div>
            `;
        }

        async function loadAnimes() {
            state.loadingAnimes = true;
            const contentArea = document.getElementById('contentArea');
            contentArea.innerHTML = '<div class="loading"><div class="spinner"></div></div>';

            try {
                addLog('üé¨ Lade Anime aus API...');
                const animes = await loadFromJikan();

                if (!animes || animes.length === 0) {
                    throw new Error('Keine Anime gefunden');
                }

                state.animes = animes.map(anime => ({
                    ...anime,
                    dubWeeks: dubTracker.getDubWeeks(anime.mal_id),
                    dubData: dubTracker.getDubData(anime.mal_id),
                    isAdult: anime.contentRating?.includes('R+') || anime.contentRating?.includes('Rx') || anime.genres?.some(g => g.name?.includes('Hentai')) || anime.title?.toLowerCase().includes('hentai'),
                    recentlyAdded: dubTracker.isRecentlyAdded(anime.mal_id)
                }));

                const seen = new Set();
                state.animes = state.animes.filter(a => {
                    const id = a.mal_id || a.id;
                    if (seen.has(id)) return false;
                    seen.add(id);
                    return true;
                });

                state.stats.totalLoaded = state.animes.length;
                state.stats.totalWithDub = state.animes.filter(a => a.dubWeeks !== null && a.dubWeeks > 0).length;

                state.apiOnline = true;
                log(`‚úì ${state.animes.length} anime loaded`);
                addLog(`‚úÖ ${state.animes.length} Anime erfolgreich geladen!`);
                showNotification(`${state.animes.length} Anime geladen ‚úì`);
                applyFilters();
                updateStats();
                updateApiStatus();

            } catch (error) {
                log(`Error: ${error.message}`);
                addLog(`‚ùå Load error: ${error.message}`);
                state.stats.errors++;
                showEmptyState(`Error: ${error.message}`);
                showNotification(`Error: ${error.message}`, true);
            } finally {
                state.loadingAnimes = false;
            }
        }

        async function loadFromJikan() {
            const results = [];
            const maxPages = 10;
            let retryCount = 0;
            const maxRetries = 2;

            for (let page = 1; page <= maxPages; page++) {
                let success = false;
                let pageRetries = 0;

                while (!success && pageRetries < maxRetries) {
                    try {
                        addLog(`üì• Loading page ${page}...`);
                        updateProgress(page, maxPages);

                        const waitTime = pageRetries > 0 ? (pageRetries * 2000) : 800;
                        await new Promise(resolve => setTimeout(resolve, waitTime));

                        const response = await fetch(
                            `https://api.jikan.moe/v4/top/anime?page=${page}&limit=25`,
                            { signal: AbortSignal.timeout(12000) }
                        );

                        if (response.status === 429) {
                            addLog(`‚è≥ Rate limit on page ${page} - waiting 3s...`);
                            await new Promise(resolve => setTimeout(resolve, 3000));
                            pageRetries++;
                            continue;
                        }

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }

                        const data = await response.json();

                        if (data.data && Array.isArray(data.data)) {
                            const animes = data.data.map(a => ({
                                mal_id: a.mal_id,
                                id: a.mal_id,
                                title: a.title || a.title_english || 'Unknown',
                                title_english: a.title_english,
                                title_japanese: a.title_japanese,
                                type: a.type,
                                episodes: a.episodes,
                                status: a.status,
                                year: a.year,
                                scored: a.scored || 0,
                                members: a.members,
                                genres: Array.isArray(a.genres) ? a.genres : [],
                                synopsis: a.synopsis || 'No description',
                                images: a.images || {},
                                contentRating: a.rating || 'PG',
                                aired: a.aired,
                                rank: a.rank || 0
                            }));

                            results.push(...animes);
                            addLog(`‚úÖ Page ${page}: ${animes.length} loaded`);
                            success = true;
                            state.loadedPages = page;
                        }
                    } catch (error) {
                        pageRetries++;
                        if (pageRetries >= maxRetries) {
                            addLog(`‚ö†Ô∏è Page ${page}: ${error.message.substring(0, 30)}`);
                            state.stats.errors++;
                            success = true;
                        }
                    }
                }
            }

            if (results.length === 0) {
                throw new Error('No anime from API');
            }

            return results;
        }

        function showEmptyState(message) {
            const contentArea = document.getElementById('contentArea');
            contentArea.innerHTML = `<div class="empty-state"><p>${message}</p></div>`;
            document.getElementById('pagination').innerHTML = '';
        }

        function setupEventListeners() {
            document.getElementById('watchlistBtn').addEventListener('click', () => {
                state.currentTab = 'watchlist';
                state.currentPage = 1;
                updateTabs();
                applyFilters();
            });

            document.getElementById('searchInput').addEventListener('input', () => {
                state.currentPage = 1;
                applyFilters();
            });

            document.getElementById('sortSelect').addEventListener('change', handleSort);
            document.getElementById('weeksFilter').addEventListener('change', () => {
                state.currentPage = 1;
                applyFilters();
            });

            document.getElementById('minRatingInput').addEventListener('input', () => {
                state.currentPage = 1;
                applyFilters();
            });

            document.getElementById('typeFilter').addEventListener('change', () => {
                state.currentPage = 1;
                applyFilters();
            });

            document.getElementById('pageSizeSelect').addEventListener('change', (e) => {
                state.pageSize = parseInt(e.target.value);
                localStorage.setItem('pageSize', state.pageSize);
                state.currentPage = 1;
                renderAnimes();
            });

            document.getElementById('closeModalBtn').addEventListener('click', closeModal);

            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    state.currentTab = btn.dataset.tab;
                    state.currentPage = 1;
                    updateTabs();
                    if (btn.dataset.tab === 'debug') {
                        showDebugInfo();
                    }
                    applyFilters();
                });
            });
        }

        function showDebugInfo() {
            const debugPanel = document.getElementById('debugPanel');
            const debugInfo = document.getElementById('debugInfo');
            if (!debugPanel) return;

            const totalDub = state.animes.filter(a => a.dubWeeks !== null).length;
            
            debugPanel.style.display = 'block';
            debugInfo.innerHTML = `
                <div class="debug-item">
                    <div class="debug-label">Total Anime</div>
                    <div class="debug-value">${state.animes.length}</div>
                </div>
                <div class="debug-item">
                    <div class="debug-label">Mit Synchronisation</div>
                    <div class="debug-value">${totalDub}</div>
                </div>
                <div class="debug-item">
                    <div class="debug-label">Pages Loaded</div>
                    <div class="debug-value">${state.loadedPages}/5</div>
                </div>
                <div class="debug-item">
                    <div class="debug-label">Watchlist</div>
                    <div class="debug-value">${state.watchlist.length}</div>
                </div>
                <div class="debug-item">
                    <div class="debug-label">Errors</div>
                    <div class="debug-value">${state.stats.errors}</div>
                </div>
                <div class="debug-item">
                    <div class="debug-label">Last Update</div>
                    <div class="debug-value">${new Date().toLocaleTimeString('de-DE')}</div>
                </div>
            `;
        }

        function updateTabs() {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tab === state.currentTab) {
                    btn.classList.add('active');
                }
            });
            updateTabCounts();
        }

        function updateTabCounts() {
            const allCount = state.currentTab === 'all' ? state.filteredAnimes.length : state.animes.length;
            const dubCount = state.animes.filter(a => a.dubWeeks !== null).length;
            const recentCount = state.animes.filter(a => a.recentlyAdded).length;
            const watchlistCount = state.watchlist.length;
            
            document.getElementById('allCount').textContent = allCount;
            document.getElementById('dubCount').textContent = dubCount;
            document.getElementById('recentCount').textContent = recentCount;
            document.getElementById('watchlistTabCount').textContent = watchlistCount;
        }

        function getDubWeeksText(weeks) {
            if (weeks === null) return 'Keine Angabe';
            if (weeks === 0) return 'Verf√ºgbar ‚úì';
            if (weeks === 1) return 'Diese Woche üî¥';
            if (weeks === 2) return 'In 1 Woche';
            if (weeks === 3) return 'In 2 Wochen';
            if (weeks === 4) return 'In 3 Wochen';
            if (weeks === 5) return 'In 4 Wochen';
            if (weeks === 6) return 'In 5-6 Wochen';
            return 'Unbekannt';
        }

        function handleSort(e) {
            const sortValue = e.target.value;
            state.filteredAnimes.sort((a, b) => {
                switch (sortValue) {
                    case 'score_desc': return (b.scored || 0) - (a.scored || 0);
                    case 'score_asc': return (a.scored || 0) - (b.scored || 0);
                    case 'year_desc': return (b.year || 0) - (a.year || 0);
                    case 'title_asc': return (a.title || '').localeCompare(b.title || '', 'en');
                    default: return 0;
                }
            });
            renderAnimes();
        }

        function toggleAdultContent() {
            state.showAdultContent = !state.showAdultContent;
            localStorage.setItem('showAdultContent', state.showAdultContent);
            document.getElementById('adultContentToggle').classList.toggle('active');
            state.currentPage = 1;
            applyFilters();
        }

        function applyFilters() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const weeksFilter = document.getElementById('weeksFilter').value;
            const minRating = parseFloat(document.getElementById('minRatingInput').value) || 0;

            state.filteredAnimes = state.animes.filter(anime => {
                const title = (anime.title || '').toLowerCase();
                const englishTitle = (anime.title_english || '').toLowerCase();

                const matchesSearch = !searchTerm || title.includes(searchTerm) || englishTitle.includes(searchTerm);
                const matchesRating = (anime.scored || 0) >= minRating;

                let matchesWeeks = true;
                if (weeksFilter) {
                    const weeks = parseInt(weeksFilter);
                    if (weeks === 0) {
                        matchesWeeks = anime.dubWeeks === 0;
                    } else {
                        matchesWeeks = anime.dubWeeks === weeks;
                    }
                }

                const matchesAdult = state.showAdultContent || !anime.isAdult;

                let matchesTab = true;
                if (state.currentTab === 'watchlist') {
                    matchesTab = state.watchlist.some(w => w.mal_id === anime.mal_id);
                } else if (state.currentTab === 'neue-dubs') {
                    matchesTab = anime.dubWeeks !== null;
                } else if (state.currentTab === 'k√ºrzlich-hinzugef√ºgt') {
                    matchesTab = anime.recentlyAdded;
                }

                return matchesSearch && matchesRating && matchesWeeks && matchesAdult && matchesTab;
            });

            const sortSelect = document.getElementById('sortSelect');
            if (sortSelect) {
                handleSort({ target: sortSelect });
            } else {
                renderAnimes();
            }
            updateTabCounts();
        }

        function renderAnimes() {
            const contentArea = document.getElementById('contentArea');

            if (!Array.isArray(state.filteredAnimes) || state.filteredAnimes.length === 0) {
                showEmptyState('No anime found üòî');
                return;
            }

            const start = (state.currentPage - 1) * state.pageSize;
            const end = start + state.pageSize;
            const paginatedAnimes = state.filteredAnimes.slice(start, end);
            const totalPages = Math.ceil(state.filteredAnimes.length / state.pageSize);

            const html = paginatedAnimes.map(anime => {
                const imageUrl = anime.images?.jpg?.image_url;
                const score = anime.scored || 0;
                const stars = Math.round(score / 2);
                const malId = anime.mal_id;
                const isWatchlisted = state.watchlist.some(w => w.mal_id === malId);
                const dubWeeks = anime.dubWeeks;
                const isRecentlyAdded = anime.recentlyAdded;

                return `
                    <div class="anime-card" onclick="openModal(${malId})">
                        <div class="anime-image">
                            ${anime.isAdult ? '<div class="adult-badge">18+</div>' : ''}
                            ${isRecentlyAdded ? '<div class="newly-added-badge">NEU</div>' : ''}
                            ${imageUrl ? `<img src="${imageUrl}" alt="${anime.title}" onerror="this.style.display='none'">` : '<span></span>'}
                            ${dubWeeks !== null ? `<div class="dub-badge"> ${getDubWeeksText(dubWeeks)}</div>` : ''}
                        </div>
                        <div class="anime-content">
                            <div class="anime-title">${anime.title}</div>
                            <div class="anime-meta">${anime.year || 'TBD'} ‚Ä¢ ${anime.type || 'N/A'}</div>
                            ${dubWeeks !== null ? `<div class="synchro-timeline"> ${getDubWeeksText(dubWeeks)}</div>` : ''}
                            <div class="anime-rating">${'‚òÖ'.repeat(Math.max(0, stars))}<span style="opacity: 0.4; font-size: 10px; margin-left: 4px;">${score.toFixed(1)}</span></div>
                            <div class="anime-actions">
                                <button onclick="event.stopPropagation(); toggleWatchlist(${malId}, '${(anime.title || '').replace(/'/g, "\\'")}');" class="${isWatchlisted ? 'active' : ''}">${isWatchlisted ? ' Gespeichert' : '+ Speichern'}</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            contentArea.innerHTML = `<div class="anime-grid">${html}</div>`;

            let paginationHtml = '';
            for (let i = 1; i <= totalPages; i++) {
                paginationHtml += `<button onclick="goToPage(${i})" class="${i === state.currentPage ? 'active' : ''}">${i}</button>`;
            }
            document.getElementById('pagination').innerHTML = totalPages > 1 ? paginationHtml : '';
        }

        function toggleWatchlist(malId, title) {
            const idx = state.watchlist.findIndex(w => w.mal_id === malId);
            if (idx > -1) {
                state.watchlist.splice(idx, 1);
                showNotification(`‚úì Removed`);
            } else {
                state.watchlist.push({ mal_id: malId, title });
                showNotification(`‚úì Added`);
            }
            localStorage.setItem('watchlist', JSON.stringify(state.watchlist));
            document.getElementById('watchlistCount').textContent = state.watchlist.length;
            applyFilters();
        }

        function openModal(malId) {
            const anime = state.animes.find(a => a.mal_id === malId);
            if (!anime) return;

            const modalBody = document.getElementById('modalBody');
            const genres = Array.isArray(anime.genres) ? anime.genres.map(g => g.name || g).join(', ') : 'N/A';
            const isWatchlisted = state.watchlist.some(w => w.mal_id === malId);
            const dubWeeks = anime.dubWeeks;

            let synchroSection = '';
            if (dubWeeks !== null) {
                const dubData = anime.dubData;
                synchroSection = `
                    <div class="synchro-details">
                        <p><strong>üé¨ Deutsche Synchronisation</strong></p>
                        <p>üìÖ ${getDubWeeksText(dubWeeks)}</p>
                        ${dubData?.streaming ? `<p>üì∫ Platform: ${dubData.streaming}</p>` : ''}
                        ${dubData?.link ? `<a href="${dubData.link}" target="_blank" style="display: inline-block; padding: 6px 12px; background: var(--info); color: white; border-radius: 4px; text-decoration: none; margin-top: 8px;">üé¨ Jetzt anschauen</a>` : ''}
                    </div>
                `;
            } else {
                synchroSection = `
                    <div style="background: rgba(243, 114, 114, 0.1); border-left: 4px solid var(--error); padding: 12px; border-radius: 4px; margin: 12px 0;">
                        <p style="color: var(--error); font-weight: 500;">‚ö†Ô∏è Keine Synchronisationsdaten bekannt</p>
                    </div>
                `;
            }

            modalBody.innerHTML = `
                <h2>${anime.title}</h2>
                ${synchroSection}
                <p><strong>English:</strong> ${anime.title_english || 'N/A'}</p>
                <p><strong>Japanese:</strong> ${anime.title_japanese || 'N/A'}</p>
                <p><strong>Type:</strong> ${anime.type || 'N/A'}</p>
                <p><strong>Episodes:</strong> ${anime.episodes || 'N/A'}</p>
                <p><strong>Status:</strong> ${anime.status || 'N/A'}</p>
                <p><strong>Rating:</strong> ${anime.scored || 'N/A'}/10</p>
                <p><strong>Year:</strong> ${anime.year || 'N/A'}</p>
                <p><strong>Genres:</strong> ${genres}</p>
                <p><strong>Synopsis:</strong></p>
                <p>${anime.synopsis}</p>
                <div style="margin-top: 24px; display: flex; gap: 12px;">
                    <button class="btn btn-primary" onclick="closeModal()">Close</button>
                    <button class="btn btn-secondary" onclick="toggleWatchlist(${malId}, '${(anime.title || '').replace(/'/g, "\\'")}'); closeModal();">${isWatchlisted ? '‚úì Remove' : '+ Save'}</button>
                </div>
            `;
            document.getElementById('detailsModal').classList.add('active');
        }

        function closeModal() {
            document.getElementById('detailsModal').classList.remove('active');
        }

        function goToPage(page) {
            state.currentPage = page;
            renderAnimes();
            window.scrollTo(0, 0);
        }

        function updateApiStatus() {
            const statusEl = document.getElementById('apiStatus');
            if (statusEl) {
                statusEl.className = 'api-status ' + (state.apiOnline ? 'online' : 'offline');
                statusEl.textContent = state.apiOnline ? 'üü¢ Online' : 'üî¥ Offline';
            }
        }

        function showNotification(message, isError = false) {
            const container = document.getElementById('notification');
            const notif = document.createElement('div');
            notif.className = `notification ${isError ? 'error' : ''}`;
            notif.textContent = message;
            container.appendChild(notif);
            setTimeout(() => notif.remove(), 3000);
        }

        document.addEventListener('DOMContentLoaded', async () => {
            log('=== Anime Synchro Tracker v9.0 Enhanced ===');
            addLog('üöÄ Starting application...');

            const saved = localStorage.getItem('watchlist');
            state.watchlist = saved ? JSON.parse(saved) : [];
            document.getElementById('watchlistCount').textContent = state.watchlist.length;

            setupEventListeners();

            try {
                document.getElementById('adultContentToggle').classList.toggle('active', state.showAdultContent);
                document.getElementById('pageSizeSelect').value = state.pageSize;

                addLog('üì° Loading sync data...');
                await dubTracker.fetchAllDubSources();

                addLog('üé¨ Loading anime from API...');
                await loadAnimes();

                addLog('‚úÖ Ready!');
                updateApiStatus();
            } catch (error) {
                log(`Error: ${error.message}`);
                addLog(`‚ùå ${error.message}`);
                state.stats.errors++;
                showNotification(`Error: ${error.message}`, true);
            }
        });
    </script>
</body>
</html>
